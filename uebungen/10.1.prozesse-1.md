# Prozesse

## Übung 1: Prozesse anzeigen
- Zeige die laufenden Prozesse in der aktuellen Shell an. 
- Verwende dazu `ps` ohne Optionen
- Starte anschließend eine weitere Shell im gleichen Terminal mit dem Kommando `bash`. 
- Führe das Kommando `ps` erneut aus. Welches ist die *Eltern-* und welches die *Kind-* Shell? Woran kann man das erkennen?

## Übung 2: Alle Prozesse anzeigen
Zeige **alle** laufenden Prozesse auf deinem System an.
- Verwende `ps aux` um alle Prozesse zu sehen
- Nutze `ps -ef` für eine andere Darstellung
- Was ist der Unterschied? Vielleicht hilft es, dir hier die Spaltennamen anzeigen zu lassen. Versuche es mit einer Pipe und `head`, so dass du nur die ersten Zeilen der Ausgabe siehst.
- Probiere `pstree` für eine Baumansicht (dazu musst du ggf. das Paket `psmisc` installieren)

## Übung 3: Prozesse nach Ressourcenverbrauch sortieren
Finde die Prozesse, die am meisten CPU und RAM verbrauchen.
- Starte `top`
- Sortiere nach CPU-Verbrauch (Taste 'P' (großes 'P') in `top`)
- Sortiere nach RAM-Verbrauch (Taste 'M' (großes 'M') in `top`)
- Verschaffe dir einen Überblick darüber, was `top` alles anzeigt und wie du damit interagieren kannst (Taste `h` im laufenden `top` drücken). Probiere ein paar Tastenkombinationen aus
- Installiere anschliessend das Paket `htop`, eine deutlich benutzerfreundlichere Variante von `top` und spiele auch damit ein wenig herum

## Übung 4: Prozess in den Hintergrund schicken
Starte einen Prozess, der lange läuft, z.B. mit `sleep`:
```bash
sleep 300
```
> [!NOTE]
> Das Kommando `sleep` macht einfach gar nichts für die Anzahl der Sekunden, die wir angeben. Wird z.B. in Skripten benutzt um ein wenig zu warten, dass eine bestimmte Aufgabe erfüllt wurde.

Du kannst nun keine Kommandos mehr ausführen, da du in einer Shell nur einen einzelnen Prozess im **Vordergrund** ausführen kannst. Du hast nun entweder die Möglichkeit, diesen Prozess zu beenden, oder ihn in den Hintergrund zu schicken. Wir probieren letzteres:
- Drücke die Tastenkombination `STRG z`
- Du kannst wieder Eingaben machen, yeah! Aber was ist mit dem Prozess passiert? Du solltest eine Ausgabe sehen wie:
```bash
[1]+  Stopped                 sleep 300
```
Der Prozess wurde in den Hintergrund geschickt **und** angehalten/gestoppt. Du kannst dir mit dem Kommando `jobs` alle sich im Hintergrund befindlichen Prozesse und deren Status anzeigen lassen.

Hole den Prozess nun mit dem Kommando `fg` wieder **in den Vordergrund** und starte ihn damit gleichzeit wieder.

Nutze erneut `STRG z` um den Prozess in den Hintergrund zu schicken (starte ggf. einen neuen), gib dann `bg` ein um den Prozess **im Hintergrund fortzusetzen** und prüfe das Ergebnis mit `jobs`

## Übung 5 Unterschied `jobs` und `ps`
Informiere dich generell über die Kommandos `ps` und `jobs`. Was ist der Unterschied? Warum hat `jobs` keine Manpage? Probiere einmal `help jobs` oder suche in der Manpage der `bash` nach `JOB CONTROL`.

## Übung 6: Prozess im Hintergrund starten
Wir können Prozesse auch direkt nach dem Start in den Hintergrund schicken und starten, in dem wir ein `&` ans Ende der Eingabe setzen:
```bash
sleep 300 &
```
- Liste alle Background-Jobs mit `jobs`
- Bringe nun `sleep` wieder in den Vordergrund mit `fg`. Dazu musst du `fg` den Index von `sleep` übergeben

> [!NOTE]
> Wir das Zeichen `&` ja schon von den Redirects zur Angabe einer Kanalnummer bzw. Filedescriptors. In diesem Fall hat es jedoch eine andere Bedeutung, es ist ein Shell-Operator, der das Kommando im Hintergrund ausführt. Es gibt hier keinen Zusammenhang, genauso wie das `*` in der Shell einmal eine Wildcard ist und in der Mathematik das Zeichen für die Multiplikation.
